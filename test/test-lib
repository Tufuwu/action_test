#!/bin/bash
#
# test-lib
#
########
#

set -u

declare -a sapHanaSr

function init() {
    verbose=0
    while [ $# -gt 0 ]; do
        case "$1" in
            --node=* ) node="${1#*=}";;
            --testCase=* ) testCase="${1#*=}";;
            --testFile=* ) testFile="${1#*=}";;
            --verbose ) verbose=1;;
        esac
        shift
    done
    logFile="./$testCase.$$.log.txt"
    storeSAPHanaSR "$node"
    loadTests "$testFile"
    #
    # get primary site and host
    #
    pSite="$(search4getObject 'Sites/.*/srr="P"')"
    pHost="$(search4getObject 'Hosts/.*/site="'"$pSite"'"')"
    sSite="$(search4getObject 'Sites/.*/srr="S"')"
    sHost="$(search4getObject 'Hosts/.*/site="'"$sSite"'"')"
    #
    # get sid, mstResource
    #
    SID="$(search4getValue 'Tests/'"$testCase"'/sid')"
    mstResource="$(search4getValue 'Tests/'"$testCase"'/mst')"
    message "INIT(): SID=$SID (${SID,,}) pHost=$pHost, pSite=$pSite, sHost=$sHost, sSite=$sSite mst=$mstResource"
    return 0
}

function message() {
    echo "$(date +'%Y-%m-%d %T') $*"
    echo "$(date +'%Y-%m-%d %T') $*" >>"$logFile"
}

function storeSAPHanaSR() {
    # purpose: get all current SAPHanaSR values
    # params:  node
    # global:  sapHanaSr(w)
    # callout: SAPHanaSR-showAttr
    # output:  -
    # rc:      0
    local node="$1"
    if [[ "$node" != "localhost" ]]; then
        mapfile -t sapHanaSr < <(ssh "$node" "SAPHanaSR-showAttr --format=script")
    else
        sapHanaSr=('Site/Mainz/srr="P"')
    fi
    return 0
}

function loadTests() {
    # purpose: get all test definitions in file
    # params:  file
    # global:  testDefinition(w)
    # callout: python3 querySteps.py
    # output:  -
    # rc:      0
    local file="$1"
    mapfile -t testDefinition < <(python3 querySteps.py < "$file")
    sapHanaSr=( "${sapHanaSr[@]}" "${testDefinition[@]}")
    return 0
}

function search4getValue() {
    # purpose: search in sapHanaSr for pattern and return value(s)
    # params:  reg Exp
    # global:  sapHanaSr(r)
    # callout: -
    # output:  value(s)
    # if it hits 'Hosts/node02/clone_state="DEMOTED"' it returns "DEMOTED"
    local regExp="$1" s r
    local -a results
    mapfile -t results < <(
            for s in "${sapHanaSr[@]}"; do
                awk -F=  '$0 ~ regExp { print $2 }' regExp="$regExp" <<<"$s";
            done
        )
    for r in "${results[@]}"; do
        echo "${r//\"/}"
    done
}

function search4getObject() {
    # purpose: search in sapHanaSr for pattern and return objects(s)
    # params:  reg Exp
    # global:  sapHanaSr(r)
    # callout: -
    # output:  value(s)
    # if it hits 'Hosts/node02/clone_state="DEMOTED"' it returns "node02"
    local regExp="$1" s r
    local -a results
    mapfile -t results < <(
            for s in "${sapHanaSr[@]}"; do
                awk -F'[/=]'  '$0 ~ regExp { print $2 }' regExp="$regExp" <<<"$s";
            done
        )
    for r in "${results[@]}"; do
        echo "${r//\"/}"
    done
}

function search4getKeyValue() {
    # purpose: search in sapHanaSr for pattern and return key-value pairs(s)
    # params:  reg Exp
    # global:  sapHanaSr(r)
    # callout: -
    # output:  value(s)
    # if it hits 'Hosts/node02/clone_state="DEMOTED"' it returns 'clone_state="DEMOTED"'
    local regExp="$1" s r
    local -a results
    mapfile -t results < <(
            for s in "${sapHanaSr[@]}"; do
                awk -F'/'  '$0 ~ regExp { print $3 }' regExp="$regExp" <<<"$s";
            done
        )
    for r in "${results[@]}"; do
        echo "${r//\"/}"
    done
}

function checkKeyValue() {
        # purpose: search in given array1 for patterns in array2
        # remark keyValues and patterns are both arrays. Each array member MUST be in the form key=value
        # output: all failed tests with leading 'ft:' at the begin of the line; 'rc:' for return codes
        local -a keyValues
        local -a patterns
        local nowPatterns=1 kV p
        local rc=0
        local -a failedTests
        local purpose
        while [ $# -gt 0 ]; do
            case "$1" in
                --purpose=* ) purpose="${1#*=}";;
                --keyValue ) nowPatterns=1;;
                --pattern ) nowPatterns=0;;
                * ) if [ "$nowPatterns" == 0 ]; then
                        patterns=( "${patterns[@]}" "$1" )
                    else
                        keyValues=( "${keyValues[@]}" "$1" )
                    fi
            esac
            shift
        done
        for p in "${patterns[@]}"; do
            kVFound=2
            # echo "DBG: keyValues: ${keyValues[*]}" >&2
            for kV in "${keyValues[@]}"; do
                # echo "DBG: ?? $kv ~ $p" >&2
                vKey="${kV%=*}"; pKey="${p%=*}"
                if [ "$vKey" == "$pKey" ]; then # if same key, check if we match
                    grep -E -q "$p" <<<"$kV" && kVFound=0 && break || kVFound=1 && break
                fi
            done
            case "$kVFound" in
                0 ) # matching
                    #echo "kV $kV matched by p $p" >&2
                    ;;
                1 ) # not matching
                    failedTests=( "${failedTests[@]}" "$purpose: $kV !~ $p" )
                    if [ "$verbose" == "1" ]; then
                        message "!!$purpose: $kV !~ $p"
                    fi
                    rc=1
                    ;;
                2)  #
                    failedTests=( "${failedTests[@]}" "$purpose: missing $p" )
                    if [ "$verbose" == "1" ]; then
                        message "$purpose: missing $p"
                    fi
                    rc=1
                    ;;
            esac
        done
        if [[ "$rc" == 1 ]]; then
            for ft in "${failedTests[@]}"; do
                echo "ft:$ft"
            done
        fi
        echo "rc:$rc"
        return "$rc"
}

function getAllKeyValue() {
    #
    #
    #
    mapfile -t primarySite   <  <(search4getKeyValue 'Sites/'"$pSite"'/')
    mapfile -t secondarySite <  <(search4getKeyValue 'Sites/'"$sSite"'/')

    mapfile -t primaryHost   <  <(search4getKeyValue 'Hosts/'"$pHost"'/')
    mapfile -t secondaryHost <  <(search4getKeyValue 'Hosts/'"$sHost"'/')
}

function checkAllKeyValueHelp() {
    # output: output of checkKeyValue()
    checkKeyValue --purpose=pSite --keyValue "${primarySite[@]}"   --pattern "${patternsPrimarySite[@]}";
    checkKeyValue --purpose=sSite --keyValue "${secondarySite[@]}" --pattern "${patternsSecondarySite[@]}";
    checkKeyValue --purpose=pHost --keyValue "${primaryHost[@]}"   --pattern "${patternsPrimaryHost[@]}";
    checkKeyValue --purpose=sHost --keyValue "${secondaryHost[@]}" --pattern "${patternsSecondaryHost[@]}";
    return 0
}

function checkAllKeyValue() {
    # output: list of failed compairs
    local rc=0 lrc
    local -a failedTests
    local -a output
    mapfile -t output < <( checkAllKeyValueHelp )
    for out in "${output[@]}"; do
        case "$out" in
            ft:* ) # failed-test entry
                   failedTests=( "${failedTests[@]}" "${out#*:}" )
                   ;;
            rc:* ) # return code entry
                   lrc=${out#*:}
                   if [[ "$lrc" -gt "$rc" ]]; then
                       rc="$lrc"
                   fi
        esac
    done
    if  [[ "$rc" -gt 0 ]]; then
        echo "${failedTests[@]}"
    fi
    return "$rc"
}

function processStep() {
    local stepID="$1"   # full ID (testCase-step)
    local repeat=60
    local interval=2
    local rc
    local postAction
    stepName="$(search4getValue "Steps/$stepID/name")"
    repeat="$(search4getValue "Steps/$stepID/loop")"
    postAction="$(search4getValue "Steps/$stepID/post")"
    #interval="$(search4getValue "Steps/$stepID/wait")"
    if [ "$verbose" == "1" ]; then
        echo "testCase=$testCase, stepID=$stepID, stepName=$stepName, repeat=$repeat theAction=$postAction" >&2
    fi
    mapfile -t patternsPrimarySite < <(search4getKeyValue "Steps/$stepID/pSite" | awk -F= '{ printf "%s=%s\n", $2,$3 }')
    mapfile -t patternsSecondarySite < <(search4getKeyValue "Steps/$stepID/sSite" | awk -F= '{ printf "%s=%s\n", $2,$3 }')
    mapfile -t patternsPrimaryHost < <(search4getKeyValue "Steps/$stepID/pHost" | awk -F= '{ printf "%s=%s\n", $2,$3 }')
    mapfile -t patternsSecondaryHost < <(search4getKeyValue "Steps/$stepID/sHost" | awk -F= '{ printf "%s=%s\n", $2,$3 }')
    message "NEXT(): $stepID ($stepName)"
    loopForStatusJson "$stepID" "$stepName" "$repeat" "$interval"; rc="$?"
    if [[ "$rc" == 0 && "$postAction" != "" ]]; then
        action "$postAction"
    fi
    return "$rc"
}

function checkPrerequisites() {
    local stepID="$1"   # full ID (testCase-step)
    local rc
    processStep "$stepID"; rc="$?"
    return "$rc"
}

function checkSequence() {
    local testCase="$1"
    local shortStepID="$2"  # short ID step (without testCase)
    local rc
    while [[ "$shortStepID" != "END" ]]; do
        processStep "${testCase}-${shortStepID}"; rc="$?"
        if [[ "$rc" != "0" ]]; then
            message "Step $shortStepID failed"
            break
        fi
        shortStepID="$(search4getValue "Steps/${testCase}-${shortStepID}/next")"
    done
    echo "checkSeqence: rc=$rc"
    return "$rc"
}

function loopForStatusJson() {
    local status="$1"
    local statusName="$2"
    local maxLoops="$3"
    local interval="$4"
    local rc=0
    local loops=0
    local lastFailedTests=""
    # TODO PRIO2: get sleep interval by parameter (post)
    if [ "$verbose" == "1" ]; then
        echo "pSite:: ${patternsPrimarySite[*]}" >&2
        echo "sSite:: ${patternsSecondarySite[*]}" >&2
    fi
    while true; do
        (( loops++ ))
        storeSAPHanaSR "$node"
        sapHanaSr=( "${sapHanaSr[@]}" "${testDefinition[@]}")
        getAllKeyValue
        if [ "$verbose" == "1" ]; then
            echo "loops $loops (maxLoops=$maxLoops)" >&2
        else
            printf "." >&2
        fi
        lastFailedTests="$(checkAllKeyValue)"; rc="$?"
        if [ "$rc" == 0 ]; then
            if [ "$verbose" != "1" ]; then
                printf " (loops=%s)\n" "$loops" # end the line of dots
            fi
            message "STATUS: REACHED STEP $status ($statusName) ####"
            break
        else
            message "DEBUG: STATUS STEP $status ($statusName)" >/dev/null   # only to logFile
            message "DEBUG: CURRENT FAILED COMPARES $lastFailedTests" >/dev/null # only to log File
            if [[ "$loops" -ge "$maxLoops"  ]]; then
                if [ "$verbose" != "1" ]; then
                    printf " (maxLoops=%s reached)\n" "$maxLoops" # end the line of dots
                fi
                message "RESULT: STATUS FAILED STEP $status ($statusName)"
                message "RESULT: LAST FAILED COMPARES $lastFailedTests"
                rc=1
                break;
            fi
        fi
        sleep "$interval"
    done
    return "$rc"
}

# TODO: to be implemented in the library and the action to be defined in the json file
function action {
    local theActionCode="$1"
    case "$theActionCode" in
        ksi ) # kill secondary instance
            local sidadm="${SID,,}adm"
            local node="$sHost"
            local rc=0
            message "ACTION: HDB kill-9 on node $node"
            echo "ssh $node su - $sidadm -c HDB kill-9" >&2
            timeout 10 ssh "$node" 'su - '"$sidadm"' -c "HDB kill-9" 2>/dev/null 1>/dev/null'; rc="$?"
            message "ACTION: HDB kill-9 on node $node rc=$rc"
            ;;
        kpi ) # kill primary instance
            local sidadm="${SID,,}adm"
            local node="$pHost"
            local rc=0
            message "ACTION: HDB kill-9 on node $node"
            timeout 10 ssh "$node" 'su - '"$sidadm"' -c "HDB kill-9" 2>/dev/null 1>/dev/null'; rc="$?"
            message "ACTION: HDB kill-9 on node $node rc=$rc"
            ;;
        cleanup ) # cleanup cluster resource
            local sidadm="${SID,,}adm"
            local node="$pHost"
            local resource="$mstResource"
            local rc=0
            message "ACTION: crm cleanup resource $resource"
            timeout 10 ssh "$node" 'crm resource cleanup '"$resource"' '; rc="$?"
            message "ACTION: crm cleanup resource $resource rc=$rc"
            ;;
        ssn ) # standby secondary node (set node running secondary to standby)
            local node="$sHost"
            message "ACTION: crm node standby $node"
            timeout 10 ssh "$node" 'crm node standby '"$node"' '; rc="$?"
            message "ACTION: crm node standby $node rc=$rc"
            ;;
        osn ) # online secondary node (set node running secondary to online)
            local node="$sHost"
            message "ACTION: crm node online $node"
            timeout 10 ssh "$node" 'crm node online '"$node"' '; rc="$?"
            message "ACTION: crm node online $node rc=$rc"
            ;;
        spn ) # standby primary node (set node running primary to standby)
            local node="$pHost"
            message "ACTION: crm node standby $node"
            timeout 10 ssh "$node" 'crm node standby '"$node"' '; rc="$?"
            message "ACTION: crm node standby $node rc=$rc"
            ;;
        opn ) # online primary node (set node running primary to online)
            local node="$pHost"
            message "ACTION: crm node online $node"
            timeout 10 ssh "$node" 'crm node online '"$node"' '; rc="$?"
            message "ACTION: crm node online $node rc=$rc"
            ;;
   esac
   return "$rc"
}

